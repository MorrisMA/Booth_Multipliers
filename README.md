Booth Multipliers in Verilog 2001
=================================

Copyright (C) 2012, Michael A. Morris <morrisma@mchsi.com>.
All Rights Reserved.

Released under LGPL.

General Description
-------------------

This repository provides several implementation of Booth Multipliers. Three Booth
algorithms are represented by the files contained in this repository:

    (a) 1 bit at a time Booth Multiplication
    (b) 2 bits at a time Booth Multiplication
    (c) 4 bits at a time Booth Multiplication

There are two examples of the Booth multiplication algorithm. The first example,
one for each type of algorithm, is an example of the direct implementation of the
Booth multiplication algorithm using a single Verilog case statement to implement
the kernel of the algorithm. The second example, one each for the 1 bit at a time
and the 4 bits at a time algorithms, is an optimization of the first example that
demonstrates the reduction of the number of adders/subtractors needed to implement
using multiple case statements and control ROMs.

Implementation
--------------

The implementation of the core provided consists of five Verilog source files
and several memory initialization files:

    Booth_Multiplier.v              - 1 bit at a time Booth multiplier (unoptimized)
        Booth_Multiplier.ucf        - User Constraints file (Xilinx)
        tb_Booth_Multiplier.v       - Test bench for verification of 4-bit implementation

    Booth_Multiplier_2x.v           - 2 bits at a time Booth multiplier (unoptimized)
        Booth_Multiplier_2x.ucf     - User Constraints file (Xilinx)
        tb_Booth_Multiplier_2x.v    - Test bench for verification of 8-bit implementation

    Booth_Multiplier_4x.v           - 4 bits at a time Booth multiplier (unoptimized)
        Booth_Multiplier_4x.ucf     - User Constraints file (Xilinx)
        tb_Booth_Multiplier_4x.v    - Test bench for verification of 8-bit implementation

    Booth_Multiplier_1xA.v          - 1 bit at a time Booth multiplier (optimized)
        Booth_Multiplier_1xA.ucf    - User Constraints file (Xilinx)
        tb_Booth_Multiplier_1xA.v   - Self-Checking Test bench for verification of 4-bit implementation

    Booth_Multiplier_4xA.v          - 4 bits at a time Booth multiplier (optimized)
        Booth_Multiplier_4xA.ucf    - User Constraints file (Xilinx)
        tb_Booth_Multiplier_4xA.v   - Self-Checking Test bench for verification of 8-bit implementation
        
    Booth_Multiplier_4xB.v          - 4 bits at a time signed/unsigned Booth multiplier (optimized)
        Booth_Multiplier_4xB.ucf    - User Constraints file (Xilinx)
        tb_Booth_Multiplier_4xB.v   - Self-Checking Test bench for verification of 8-bit implementation
            Booth_Multipliers.tcl           - Project settings TCL file
    
(The optimized implementations are tested against the data generated by the corresponding
unoptimized modules. The unoptimized 4x module has been successfully utilized in an FPGA for a
motor speed control system of two variable displacement, reversible, high-speed hydraulic motors.)

Synthesis Results
-----------------

The synthesis results are provided in the following table for 16x16 Booth multiplier
in a Spartan 3AN FPGA using the ISE 10.1i SP3 toolset to implement each of the algorithms:

    Algorithm:                      1x      2x      4x      1xA     4xA
    Number of Slice FFs:            91      92      92      87      98
    Number of 4-input LUTs:         80      101     238     62      193
    Number of Occupied Slices:      71      97      169     68      138
    
    Period Constraint (ns):         5       6       9.75    4.75    7.85
    Best Case Achievable (ns):      4.925   5.906   9.675   4.725   7.839
    
Refer to the TCL file for the synthesizer and PAR settings used to generate the results
in the table.

Status
------

Design and verification is complete. 4x module used in a control systems project
in a 40 bit fixed point ALU.